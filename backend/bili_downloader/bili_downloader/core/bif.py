# backend/bili_downloader/bili_downloader/core/bif.py
import os
import subprocess
import struct
import tempfile
import shutil
import glob # 用于查找文件
import sys # <-- 添加导入

def generate_bif(video_path: str, bif_path: str, interval: int = 1, width: int = 480):
    """
    Generates a BIF file from a video file using FFmpeg.

    Args:
        video_path: Path to the input video file.
        bif_path: Path where the output BIF file will be saved.
        interval: Interval between keyframes in seconds.
        width: Width of the thumbnail images.

    Returns:
        bool: True if successful, False otherwise.
        str: Error message if failed, None otherwise.
    """
    temp_dir = None
    try:
        if not os.path.exists(video_path):
            return False, f"Video file not found: {video_path}"

        os.makedirs(os.path.dirname(bif_path), exist_ok=True)
        temp_dir = tempfile.mkdtemp(prefix="bif_thumbnails_")
        print(f"[BIF] Created temp directory: {temp_dir}")
        sys.stdout.flush() # <-- 添加刷新

        # --- Step 1: Extract thumbnails using FFmpeg ---
        ffmpeg_cmd = [
            'ffmpeg',
            '-i', video_path,
            '-an', '-sn', # No audio, no subtitles
            '-vf', f"select='eq(pict_type,I)',fps=1/{interval},scale={width}:-1",
            '-vsync', 'vfr',
            os.path.join(temp_dir, 'thumb-%05d.jpg') # Use more digits for longer videos
        ]
        print(f"[BIF] Running FFmpeg command: {' '.join(ffmpeg_cmd)}")
        sys.stdout.flush() # <-- 添加刷新
        # Use startupinfo on Windows to hide console window
        startupinfo = None
        if os.name == 'nt':
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess.SW_HIDE

        process = subprocess.run(ffmpeg_cmd, capture_output=True, text=True, check=False, startupinfo=startupinfo, encoding='utf-8', errors='ignore')


        if process.returncode != 0:
            # Try to decode stderr even if there were errors
            stderr_output = process.stderr if process.stderr else "(no stderr)"
            error_msg = f"FFmpeg failed (code {process.returncode}): {stderr_output[:500]}..." # Limit error length
            print(f"[BIF] {error_msg}")
            sys.stdout.flush() # <-- 添加刷新
            return False, error_msg

        print("[BIF] FFmpeg finished extracting thumbnails.")
        sys.stdout.flush() # <-- 添加刷新

        # --- Step 2: Find generated thumbnails and get timestamps (approximate) ---
        thumbnail_files = sorted(glob.glob(os.path.join(temp_dir, 'thumb-*.jpg')))
        if not thumbnail_files:
             # Check FFmpeg output again in case of silent failure
             stderr_output = process.stderr if process.stderr else "(no stderr)"
             stdout_output = process.stdout if process.stdout else "(no stdout)"
             print(f"[BIF] FFmpeg completed but no thumbnails found. Stdout: {stdout_output[:200]}... Stderr: {stderr_output[:500]}...")
             sys.stdout.flush() # <-- 添加刷新
             return False, "No thumbnails were generated by FFmpeg."

        print(f"[BIF] Found {len(thumbnail_files)} thumbnails.")
        sys.stdout.flush() # <-- 添加刷新

        timestamps_ms = []
        images_data = []
        # Approximate timestamp calculation
        for i, thumb_path in enumerate(thumbnail_files):
             ts_ms = i * interval * 1000
             timestamps_ms.append(ts_ms)
             try:
                 with open(thumb_path, 'rb') as f_thumb:
                     images_data.append(f_thumb.read())
             except IOError as e:
                 print(f"[BIF] Failed to read thumbnail {thumb_path}: {e}") # <-- 错误日志也要刷新
                 sys.stdout.flush()
                 return False, f"Failed to read thumbnail {thumb_path}: {e}"


        # --- Step 3: Assemble the BIF file ---
        image_count = len(thumbnail_files)
        index_entry_size = 8 # 4 bytes timestamp + 4 bytes offset
        header_size = 64
        index_size = (image_count + 1) * index_entry_size # +1 for the terminator
        first_image_offset = header_size + index_size

        offsets = []
        current_offset = first_image_offset

        with open(bif_path, 'wb') as f_bif:
            # Write Header (Little-Endian)
            f_bif.write(b'\x89BIF\r\n\x1a\n')          # Magic number (8 bytes)
            f_bif.write(struct.pack('<I', 0))              # Version (4 bytes)
            f_bif.write(struct.pack('<I', image_count))     # Number of images (4 bytes)
            f_bif.write(struct.pack('<I', 1000))           # Timestamp multiplier (ms) (4 bytes)
            f_bif.write(b'\x00' * 44)                      # Reserved (44 bytes)

            # Pre-calculate offsets before writing index
            for img_data in images_data:
                offsets.append(current_offset)
                current_offset += len(img_data)

            # Write Index Table
            for i in range(image_count):
                f_bif.write(struct.pack('<I', timestamps_ms[i])) # Timestamp (ms)
                f_bif.write(struct.pack('<I', offsets[i]))       # Offset

            # Write Terminator Entry
            f_bif.write(struct.pack('<I', 0xFFFFFFFF)) # Terminator timestamp
            f_bif.write(struct.pack('<I', current_offset)) # Offset *after* last image data

            # Write Image Data
            f_bif.seek(first_image_offset)
            for img_data in images_data:
                f_bif.write(img_data)

        print(f"[BIF] Successfully created BIF file: {bif_path}")
        sys.stdout.flush() # <-- 添加刷新
        return True, None

    except FileNotFoundError:
        error_msg = "FFmpeg command not found. Please ensure FFmpeg is installed and in your system's PATH."
        print(f"[BIF] {error_msg}")
        sys.stdout.flush() # <-- 添加刷新
        return False, error_msg
    except Exception as e:
        error_msg = f"Error generating BIF file: {e}"
        print(f"[BIF] {error_msg}")
        sys.stdout.flush() # <-- 添加刷新
        import traceback
        traceback.print_exc()
        sys.stdout.flush() # <-- 添加刷新
        return False, error_msg

    finally:
        # --- Step 4: Cleanup ---
        if temp_dir and os.path.exists(temp_dir):
            try:
                shutil.rmtree(temp_dir)
                print(f"[BIF] Removed temp directory: {temp_dir}")
                sys.stdout.flush() # <-- 添加刷新
            except Exception as e:
                print(f"[BIF] Warning: Failed to remove temp directory {temp_dir}: {e}")
                sys.stdout.flush() # <-- 添加刷新 